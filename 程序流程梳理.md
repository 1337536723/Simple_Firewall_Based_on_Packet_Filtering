#程序流程梳理

要实现新的功能首先要理解这个防火墙程序是如何进行工作的，通过在函数中加入AfxMessageBox输出，我梳理了一遍程序启动以及各按钮点击事件的流程。注意，下列流程是**按函数调用的次序**给出的，不是函数结束的次序。

##运行

```c
01. TDriver() // 调用3次

02. CAddRuleDlg()
03. LoadDriver(LPCTSTR name, LPCTSTR path, LPCTSTR dosName, BOOL start)
04. InitDriver(LPCTSTR name, LPCTSTR path, LPCTSTR dosName)
05. LoadDriver(BOOL start)
06. StartDriver(void)
07. OpenDevice(void) // 开启设备句柄

08. CFireView()
09. Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)
10. PreCreateWindow(CREATESTRUCT& cs)

11. LoadDriver(LPCTSTR name, LPCTSTR path, LPCTSTR dosName, BOOL start)
12. InitDriver(LPCTSTR name, LPCTSTR path, LPCTSTR dosName)
13. LoadDriver(BOOL start)
14. StartDriver(void)
15. OpenDevice(void)

16. LoadDriver(LPCTSTR name, LPCTSTR path, LPCTSTR dosName, BOOL start)
17. InitDriver(LPCTSTR name, LPCTSTR path, LPCTSTR dosName)
18. LoadDriver(BOOL start)
19. StartDriver(void)
20. OpenDevice(void)

21. OnShowWindow(BOOL bShow, UINT nStatus)
22. AddHeader(LPTSTR hdr) // 调用8次，对应过滤规则的8个字段
23. OnInitialUpdate()
24. ShowHeaders()
25. // 界面出现
```

##点击View rules
```c
01. OnViewrules()
02. ImplementRule(void)

//每一条规则都会调用以下三个函数
03. ParseToIp(CString str)
//此时过滤规则出现在界面
04. AddFilter(IPFilter pf)
05. WriteIo
```

##点击Add Rule
```c
01. OnAddrule()

//输入IP地址后点击其它输入框
02. Verify(CString str)

//点击Save
03. OnAddsave()
04. NewFile(void)
05. SaveFile(char* str)
06. CloseFile()
07. AddFilter(IPFilter pf)
08. WriteIo
```

##点击Block Ping或Block All
```c
01. OnBlockping() //或OnBlockall()
02. AddFilter(IPFilter pf)
03. WriteIo
```

##点击Allow All
```c
01. OnAllowall()
02. WriteIo
```

##点击Start
```c
01. OnStart()
02. WriteIo
```

##点击Stop
```c
01. OnStop() // 调用OnStart函数，
02. OnStart() // 在OnStart中再判断用户点击的按钮然后执行相应的逻辑
03. WriteIo
```

## 关于TDriver

TDriver是一个用于与驱动打交道的类，共有3个实例，其中：

AddRuleDlg有一个：ipFltDrv（负责所有添加过滤规则的操作）

fireView有两个：m_filterDriver（负责清除过滤规则、开始过滤、停止过滤）和m_ipFltDrv

- fireView的m_ipFltDrv出现在四处：
```c
01. LoadDriver("DrvFltIp", NULL, NULL, TRUE); //PreCreateWindow(CREATESTRUCT& cs)中
02. m_ipFltDrv.WriteIo(START_IP_HOOK, NULL, 0); //OnStart()中
03. m_ipFltDrv.WriteIo(STOP_IP_HOOK, NULL, 0); //OnStart()中
04. m_ipFltDrv.WriteIo(CLEAR_FILTER,NULL,0); //OnAllowall()中
```

- fireView的m_filterDriver出现在PreCreateWindow(CREATESTRUCT& cs)中的两处：
```c
01. m_filterDriver.LoadDriver("IpFilterDriver", "System32\\Drivers\\IpFltDrv.sys", NULL, TRUE);
02. m_filterDriver.SetRemovable(FALSE); //在Destructor(析构函数)中不注销这个设备
```

- AddRuleDlg的ipFltDrv出现在两处：
```c
01. ipFltDrv.LoadDriver("DrvFltIp", NULL, NULL, TRUE); //在构造函数中
02. ipFltDrv.WriteIo(ADD_FILTER, &pf, sizeof(pf)); //在AddFilter(IPFilter pf)中
```

**Notice：**

1. System32\Drivers目录下的ipfltdrv.sys是Microsoft提供的**IP协议过滤驱动程序**，允许用户注册自己的IP包处理函数(Hook)，从而进行包过滤。更详细的介绍可以查看[MSDN](https://msdn.microsoft.com/zh-cn/library/ff545404(v=vs.85).aspx)和[百度文库](http://wenku.baidu.com/view/8851c79b83d049649b66585b.html?re=view)。

2. 虽然有3个TDriver实例，但其实只用到了两个驱动程序，一个是系统自带的ipfltdrv.sys，另一个是程序创建的drvfltip.sys。

##怎么看待ipfltdrv.sys和drvfltip.sys

drvfltip.sys是一个**Filter-Hook Driver**，是从Windows2000开始提供的一种驱动程序。它主要**利用ipfiltrdrv.sys所提供的功能**来拦截网络封包，但**它本身不是网络驱动**。在Filter-Hook Driver中，我们提供回调函数(callback)，然后使用IP Filter Driver(ipfiltrdrv.sys)注册回调函数()。这样当数据包发送和接收时，IP Filter Driver会调用回调函数进行处理，从而实现过滤特定数据包的目的。

##5种CTL_CODE（设备控制代码）

```c
01. START_IP_HOOK //开始过滤
02. STOP_IP_HOOK  //停止过滤
03. ADD_FILTER    //增加过滤规则
04. CLEAR_FILTER  //清除所有过滤规则
05. READ_FILTER   //读取过滤规则（未用到）
```

##最后！！

放上两篇对理解比较有帮助的文章[回调函数以及钩子函数的概念](http://developer.51cto.com/art/201105/263407.htm)和[开发Windows 2000/XP下的防火墙](http://www.vckbase.com/index.php/wv/801.html)。

文中介绍过滤的流程如下：

1. 建立Filter-Hook Driver，可以选择名称，DOS名称和其它驱动特性，这些不是必须的，但建议使用描述名称。
2. 要安装过滤函数，首先我们必须得到指向IP Filter Driver的指针。
3. 取得了指针后，我们可以通过发送特殊的IRP来安装过滤函数，该"消息"传递的数据包含了过滤函数的指针。
4. 过滤数据包。
5. 结束过滤时要撤销过滤函数。可以通过传递null指针作为过滤函数指针来实现。

我的理解是，代码中的5个CTL_CODE就是钩子函数Hook。所谓钩子函数，其实是回调函数的一个特例，把这样的函数作为参数传给驱动，当用户触发特定事件时，这些函数就被调用并用于处理截获的消息。

用户可以在程序界面添加/删除规则，然后规则被加载（或者说安装，WriteIo）到驱动，当用户点击Start时，驱动开始根据接收到的过滤规则对数据包进行过滤。实验中，drvfltip.sys驱动是提供好的，不需要我们自己生成（所以项目代码中不涉及前面的步骤3，这段逻辑由驱动程序负责，我们只需要把规则写到drvfltip驱动上就可以了）。

